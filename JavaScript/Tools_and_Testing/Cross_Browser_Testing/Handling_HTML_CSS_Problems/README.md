# Handling common HTML and CSS problems

With the scene set, we'll now look specifically at the common cross-browser problems you will come across in HTML and CSS code, and what tools can be used to prevent problems from happening, or fix problems that occur. This includes linting code, handling CSS prefixes, using browser dev tools to track down problems, using polyfills to add support into browsers, tackling responsive design problems, and more.

## The trouble with HTML and CSS

Some of the trouble with HTML and CSS lies with the fact that both languages are fairly simple, and often developers don't take them seriously, in terms of making sure the code is well-crafted, efficient, and semantically describes the purpose of the features on the page. In the worst cases, JavaScript is used to generate the entire web page content and style, which makes your pages inaccessible, and less performant (generating DOM elements is expensive). In other cases, nascent features are not supported consistenly across browsers, which can make some features and styles not work for some users. Responsive design problems are also common -- a site that looks good in a desktop browser might provide a terrible experience on a mobile device, because the content is too small to read, or perhaps the site is slow because of expensive animations.

Let's go forth and look at how we can reduce cross browser errors that result from HTML/CSS.

## First things first: fixing general problems

We said in the [first article of this series](https://github.com/AndrewSRea/My_Learning_Port/tree/main/JavaScript/Tools_and_Testing/Cross_Browser_Testing/Introduction#introduction-to-cross-browser-testing) that a good strategy to begin with is to test in a couple of modern browsers on desktop/mobile, to make sure your code is working generally, before going on to concentrate on the cross browser issues.

In our [Debugging HTML](https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Debugging_HTML) and [Debugging CSS](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Debugging_CSS) articles, we provided some really basic guidance on debugging HTML/CSS -- if you are not familiar with the basics, you should definitely study these articles before carrying on.

Basically, it is a matter of checking whether your HTML and CSS code is well-formed and doesn't contain any syntax errors.

<hr>

**Note**: One common problem with CSS and HTML arises when different CSS rules begin to conflict with one another. This can be especially problematic when you are using third party code. For example, you might use a CSS framework and find that one of the class names it uses clashes with one you've already used for a different purpose. Or you might find that HTML generated by some kind of third party API (generating ad banners, for example) includes a class name or ID that you are already using for a different purpose. To ensure this doesn't happen, you need to research the tools you are using first and design your code around them. It is also worth "namespacing" CSS, e.g. if you have a widget, make sure it has a distinct class, and then start the selectors that select elements inside the widget with this class, so conflicts are less likely. For example, `.audio-player ul a`.

<hr>

### Validation

For HTML, validation involves making sure all your tags are properly closed and nested, you are using a DOCTYPE, and you are using tags for their correct purpose. A good strategy is to validate your code regularly. One service that can do this is the W3C [Markup validation Service](), which allows you to point to your code using a [URI](https://danielmiessler.com/study/difference-between-uri-url/), your local computer's file path, or by directly entering the code into a textbox, and the app will return a list of errors:

![Image of the W3C Markup Validation Service](https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing/HTML_and_CSS/validator.png)

CSS has a similar story -- you need to check that your property names are spelled correctly, property values are spelled correctly and are valid fo the properties that are used on, you are not missing any curly braces, and so on. The W3C has a [CSS Validator](https://jigsaw.w3.org/css-validator/) available, too, for this purpose.

### Linters

Another good option to choose is a so-called Linter application, which not only points out errors but can also flag up warnings about bad practices in your CSS, and other points besides. Linters can generally be customized to be stricter or more relaxed in their error/warning reporting.

There are many online linter applications, the best of which are probably [Dirty Markup](https://www.10bestdesign.com/dirtymarkup/) (HTML, CSS, JavaScript), and [CSS Lint](http://csslint.net/) (CSS only). These allow you to paste your code into a window, and it will flag up any errors with crosses, which can then be hovered over to get an error message informing you what the problem is. Dirty Markup also allows you to make fixes to your markup using the *Clean* button.

<hr>

**Personal note**: The design of the **Dirty Markup** linter listed above did not instill me with a lot of confidence in the ability of the app. (It looks like the website hasn't been maintained in quite a while.)

Through some internet searching, I found a GitHub page with a developer community-created list of [awesome-linters](https://github.com/caramelomartins/awesome-linters) for many code languages, including [HTML](https://github.com/caramelomartins/awesome-linters#html), [CSS](https://github.com/caramelomartins/awesome-linters#css), and [JavaScript](https://github.com/caramelomartins/awesome-linters#javascript).

<hr>

![Image of the Dirty Markup app highlighting errors in code](https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing/HTML_and_CSS/dirty-markup.png)

However, it is not very convenient to have to copy and paste your code over to a webpage to check its validity several times. What you really want is a linter that will fit into your standard workflow with the minimum of hassle.

Many code editors have linter plugins. GitHub's [Atom](https://atom.io/) code editor, for example, has a rich plugin ecosystem available, with amny linting options. To show you an example of how such plugins generally work:

**(These instructions do not have to be followed if you already have a code editor installed in your local computer, and wish to install code linters in your already-downloaded code editor. See below these instructions.)**

1. Install Atom (if you haven't got an up-to-date version already installed) -- download it from the Atom page linked above.
2. Go to Atom's *Preferences...* dialog (e.g. by choosing *Atom > Preferences...* on Mac, or *File > Preferences...* on Windows/Linux) and choose the *Install* option in the left hand menu.
3. In the *Search packages* text field, type "lint" and press Enter/Return to search for linting-related packages.
4. You should see a package called **lint** at the top of the list. Install this first (using the *Install* button), as other linters rely on it to work. After that, install the **linter-csslint** plugin for linting CSS, and the **linter-tidy** plugin for linting HTML.
5. After the packages have finished installing, try loading up an HTML file and a CSS file: you'll see any issues highlighted with green (for warnings) and red (for errors) circles next to the line numbers, and a separate panel at the bottom provides line numbers, error messages, and sometimes suggested values or other fixes.

![Image of "linter-tidy" working on HTML code](https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing/HTML_and_CSS/atom-htmltidy.png)

![Image of "linter-csslint" working on CSS code](https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing/HTML_and_CSS/atom-csslint.png)

Other popular editors have similar linting packages available. For example, see:

* [SublimeLinter](http://www.sublimelinter.com/en/stable/) for Sublime Text
* [Notepad++ linter](https://sourceforge.net/projects/notepad-linter/)
* [VSCode linters](https://marketplace.visualstudio.com/search?target=vscode&category=Linters&sortBy=Installs)

### Browser developer tools

The developer tools built into most browsers also feature useful tools for hunting down errors, mainly for CSS.

<hr>

**Note**: HTML errors don't tend to show up so easily in dev tools, as the browser will try to correct badly-formed markup automatically. The W3C validator is the best way to find HTML errors -- see [Validation](https://github.com/AndrewSRea/My_Learning_Port/tree/main/JavaScript/Tools_and_Testing/Cross_Browser_Testing/Handling_HTML_CSS_Problems#validation) above.

<hr>

As an example, in Firefox the CSS inspector will show CSS declarations that aren't applied crossed out, with a warning triangle. Hovering over the warning triangle will provide a descriptive error message:

![Image of a dev tools CSS inspector](https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing/HTML_and_CSS/css-message-devtools.png)

Other browser devtools have similar features.

## Common cross browser problems

Now let's move on to look at some of the most common cross browser HTML and CSS problems. The main areas we'll look at are lack of support for modern features, and layout issues.

### Older browsers not supporting modern features 

This is a common problem, especially when you need to support old browsers (such as old IE versions) or you are using features that are implemented using CSS prefixes. In general, most core HTML and CSS functionality (such as basic HTML elements, CSS basic colors and text styling) works across most browsers you'll want to support. More problems are uncovered when you start wanting to use newer features such as [Flexbox](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox), or [HTML5 video/audio](https://developer.mozilla.org/en-US/docs/Web/Guide/Audio_and_video_delivery), or even more nascent, [CSS Grids](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Grids#native_css_grids_with_grid_layout) or [-webkit-background-clip: text](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Advanced_styling_effects#-webkit-background-clip_text).

Once you've identified a list of potential problem technologies you will be using, it is a good idea to research what browsers they are supported in, and what related techniques are useful. See [Finding help]() below.

#### HTML fallback behavior

Some problems can be solved by just taking advantage of the natural way in which HTML/CSS work.

Unrecognized HTML elements are treated by the browser as anonymous inline elements (effectively inline elements with no semantic value, similar to [`<span>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span) elements). You can still refer to them by their names, and style them with CSS, for example -- you just need to make sure they are behaving as you want them to. For example, setting `display: block;` on all of the new semantic elements (such as [`<article>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/article), [`<aside>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/aside), etc.), but only in old versions of IE that don't recognize them (so, IE 8 and lower). This way new browsers can just use the code as normal, but older IE versions will be able to style these elements, too.

<hr>

**Note**: See [IE conditional comments]() for the best way to do this. <!-- below -->

<hr>

More complex elements like HTML [`<video>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video), [`<audio>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio), and [`<canvas>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas) (and other features besides) have natural mechanisms for fallbacks to be added, which work on the same principle as described above. You can add fallback content in between the opening and closing tags, and non-supporting browsers will effectively ignore the outer element and run the nested content.

For example:
```
<video id="video" controls preload="metadata" poster="img/poster.jpg">
    <source src="video/tears-of-steel-battle-clip-medium.mp4" type="video/mp4">
    <source src="video/tears-of-steel-battle-clip-medium.webm" type="video/webm">
    <!-- Offer download -->
    <p>Your browser does not support HTML5 video; here is a link to
    <a href="video/tears-of-steel-battle-clip-medium.mp4">view the video</a> directly.</p>
</video>
```
This example includes a simple link allowing you to download the video if even the HTML5 video player doesn't work so, at least, the user can still access the video.

HTML5 form elements also exhibit fallback qualities -- HTML5 introduced some special [`<input>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input) types for inputting specific information into forms, such as times, dates, colors, numbers, etc. These are very useful, particularly on mobile platforms, where providing a pain-free way of entering data is very important for the user experience. Supporting platforms provide special UI widgets when these input types are used, such as a calendar widget for entering dates.

The following example shows date and time inputs:
```
<form>
    <div>
        <label for="date">Enter a date:</label>
        <input id="date" type="date">
    </div>
    <div>
        <label for="time">Enter a time:</label>
        <input id="time" type="time">
    </div>
</form>
```
You can see the output of this code running live as [forms-test.html](https://mdn.github.io/learning-area/tools-testing/cross-browser-testing/html-css/forms-test.html) on GitHub. (And see the [source code](https://github.com/mdn/learning-area/blob/master/tools-testing/cross-browser-testing/html-css/forms-test.html) as well.)

If you view the example on a supporting browser like desktop/Android Chrome or iOS Safari, you'll see the special widgets/features in action as you try to input data. On a non-supporting platform such as Firefox or Internet Explorer, the inputs will just fallback to normal text inputs so, at least, the user can still enter some information.

<hr>

**Note**: Of course, this may not be a great solution for your project's needs -- the difference in visual presentation is not great, plus it is harder to guarantee the data will be entered in the format you want it in. For cross browser forms, it is probably better to rely on simple form elements, or selectively use advanced form elements only in supporting browsers, or using a library that provides decent cross browser form widgets, such as [jQuery UI](https://jqueryui.com/) or [Bootstrap datepicker](https://bootstrap-datepicker.readthedocs.io/en/latest/).

<hr>

#### CSS fallback behavior

CSS is arguably better at fallbacks than HTML. If a browser encounters a declaration or rule it doesn't understand, it just skips it completely without applying it or throwing an error. This might be frustrating for you and your users if such a mistake slips through to production code but, at least, it means the whole site doesn't come crashing down because of one error and, if used cleverly, you can use it to your advantage.

Let's look at an example -- a simple box styled with CSS, which has some styling provided by various CSS3 features. You can see this example running live on GitHub as [button-with-fallback.html](https://mdn.github.io/learning-area/tools-testing/cross-browser-testing/html-css/button-with-fallback.html), and see the [source code](https://github.com/mdn/learning-area/blob/master/tools-testing/cross-browser-testing/html-css/button-with-fallback.html) as well.

The button has a number of declarations that style, but the two we are most interested in are as follows:
```
button {
    ...

    background-color: #ff0000;
    background-color: rgba(255,0,0,1);
    box-shadow: inset 1px 1px 3px rgba(255,255,255,0.4),
                inset -1px -1px 3px rgba(0,0,0,0.4);
}

button:hover {
    background-color: rgba(255,0,0,0.5);
}

button:active {
    box-shadow: inset 1px 1px 3px rgba(0,0,0,0.4),
                inset -1px -1px 3px rgba(255,255,255,0.4);
}
```
Here we are providing an [RGBA](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgba()) [`background-color`](https://developer.mozilla.org/en-US/docs/Web/CSS/background-color) that changes opacity on hover to give the user a hint that the button is interactive, and some semi-transparent inset [`box-shadow`](https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow) shades to give the button a bit of texture and depth. The trouble is that RGBA colors and box shadows don't work in IE versions older than 9 -- in older versions, the background just wouldn't show up at all so the text would be unreadable, no good at all!

To sort this out, we have added a second a second `background-color` declaration, which just specifies a hex color -- this is supported way back in really old browsers, and acts as a fallback if the modern shiny features don't work. What happens is a browser visiting this page first applies the first `background-color` value; when it gets to the second `background-color` declaration, it will override the initial value with this value if it supports RGBA colors. If not, it will just ignore the entire declaration and move on.

<hr>

**Note**: The same is true for other CSS features like [media queries](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries), [`@font-face`](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face), and [`@supports](https://developer.mozilla.org/en-US/docs/Web/CSS/@supports) blocks -- if they are not supported, the browser just ignores them.

<hr>

#### IE conditional comments

IE conditional comments are a modified proprietary HTML comment syntax, which can be used to selectively apply HTML code to different versions of IE. This has proven to be a very effective mechanism for fixing cross browser bugs. The syntax looks like this:
```
<!--[if lte IE 8]>
    <script src="ie-fix.js"></script>
    <link href="ie-fix.css" rel="stylesheet" type="text/css">
<![endif]-->
```
This block will apply the IE-specific CSS and JavaScript only if the browser viewing the page is IE 8 or older. `lte` means "less than or eqaul to", but you can also use `lt`, `gt`, `gte`, `!` for NOT, and other logical syntax.

<hr>

**Note**: Sitepoint's [Internet Explorer Conditional Comments](https://www.sitepoint.com/internet-explorer-conditional-comments/) provides a useful beginner's tutorial/reference that explains the conditional comment syntax in detail.

<hr>

As you can see, this is especially useful for applying code fixes to old versions of IE. The use case we mentioned earlier (making modern semantic elements stylable in old versions of IE) can be achieved easily using conditional comments. For example, you could put something like this in your IE stylesheet:
```
aside, main, article, section, nav, figure, figcaption {
    display: block;
}
```
It isn't that simple, however -- you also need to create a copy of each element you want to style in the DOM via JavaScript, for them to be stylable. This is a strange quirk, and we won't bore you with the details here. For example:
```
const asideElem = document.createElement('aside');
    ...
```
This seems like a pain to deal with, but fortunately there is a [polyfill](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill) available that does the necessary fixes for you, and more besides -- see [HTML5Shiv](https://github.com/aFarkas/html5shiv) for all the details. (See [manual installation](https://github.com/aFarkas/html5shiv#installation) for the simplest usage.)